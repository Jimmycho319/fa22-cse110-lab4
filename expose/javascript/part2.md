1. Line 12 would print the value 3 because that is the last value that is set by the for loop and we are able to access this variable because it is of type var, accessible from anywhere in the function
2. Line 13 would print out the value 150 because that is the last value that was given to the variable discountedPrice and since it is of type var, it will be accessible even though it is technically not in the same block
3. Line 14 would also give us the value 150 because it is also of type var and is the same value as discountedPrice because the round() function will not do anything to the value because there is nothing to round to.
4. Would return [50,100,150] it will work as intended where they will take the values in the list and the values that represents the discounted prices and through the for loop, we will create a new list called discounted which will store the discounted values of the items
5. Line 12 would give us an error because we are trying to call i which was of variable type 'let' outside of the block that it is initiallized in
6. This would give us an error because we are out of scope of the place where the let variable discountedPrice was initialized
7. This will print 150 without an error because we are in scope of the block where the vairable finalPrice was initialized.
8. This function would return [50, 100, 150] because as expected just as the previous version of this function with the var type variables
9. This code would raise an error because again we are trying to access the variable i which is of variable type 'let' which goes out of scope when it comes out of the for loop.
10. Line 12 would print the value 3 because it is 1. in scope, 2. does not raise an error because it is not changed after initialization. The value 3 comes from the length of the list which is 3
11. This funciton will return the values [50,100,150] as expected and with consistency with the other versions of this funciton with different variable types.
12. a. student.name, b. student['Grad Year'], c. student.greeting(), d. student['Favorite Teacher']['name'], e. student['courseLoad'][0]
13. A. '32' changes type to string and concatentates 2, B. 1 subtract changes the type to int and does 3-2 arithmetic, C. 3 adding keeps the type of the first variable and since null is 0 we get 3, D. '3null', again keeps the type of the fist variable and just concatenates the null to the string, E. 4, true value is 1 so 1 + 3 keeping the integer value will give us the sum 4, F. 0, changes the type to integer and since false is 0 and null is also integer value we get 0, G. '3undefined', again we will be concatentating the string 'undefined' to '3', H. NaN, undefined becomes NaN when converted to type int
14. A. True, when comparing string and int, string becomes int for comparison, B.  False, When comparing 2 strings, they use lexicographical ordering and so since 2 is greater than 1, this becomes false, C. True, because when comparing an integer and a string, we compare the numberical values of the int and the int form of the string, D. False because for triple equals first it checks if they are of the same type and if they are not, it will return a false, E. False because true in integer form is 1 which is not equal to 2, F. True because true and Boolean(2) are the same thing and the same type
15. The difference between == and === is that === does not do type conversions when comparing the two sides and will simply return false if they are not of the same type.
16. separate file
17. The result will be that we get back from the function call: [2,4,6]. We are passing a function that will return the value that is given * 2 and we will be using that inside of a function that will iterate through a list and add the number from the given array after running the passed function on the element. Therefore, since the function that is passed will return the value * 2, we will get a list of elements that is increased by x2.
18. separate file
19. The output would be 1 4 3 2 since the setTimeout functions will execute after the function that is below it and then the timers will start. Since set second instance of setTimeout has a delay of 0ms and the first instance has 1000ms, the 3 will be printed before the 2